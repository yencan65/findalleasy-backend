// server/routes/affiliateBridgeS16.js
// ===================================================================
// AFFILIATE BRIDGE — S16 (Click-out + Postback-in + Dedup)
// - /out/:provider  -> clickId üret, click logla, affiliate url üret, redirect
// - /postback/:provider -> conversion al, dedup yap, paid ise rewardEngine tetikle
// - DB yoksa: PROD'da blokla (para kaybı olmasın), DEV'da opsiyonel izin ver
// ===================================================================

import express from "express";
import crypto from "crypto";
import mongoose from "mongoose";

import { applyRewardsForOrder } from "../core/rewardEngine.js";

try {
  mongoose.set("bufferCommands", false);
} catch {}

const router = express.Router();
router.use(express.json({ limit: "256kb" }));
router.use(express.urlencoded({ extended: true }));

// ----------------------------
// ENV
// ----------------------------
const AFFILIATE_ID = String(process.env.FAE_AFFILIATE_ID || "").trim();
const POSTBACK_SECRET = String(process.env.FAE_POSTBACK_SECRET || "").trim();

// PROD güvenliği: DB yoksa /out çalışmasın (clickId kaybolur -> conversion map yok -> para kaybı)
const OUT_ALLOW_WHEN_DB_DOWN =
  String(process.env.FAE_OUT_ALLOW_WHEN_DB_DOWN || "0") === "1";

// postback'te paid sayılacak status listesi
const PAID_STATUSES = new Set(
  String(process.env.FAE_PAID_STATUSES || "paid,success,approved,payout")
    .split(",")
    .map((s) => s.trim().toLowerCase())
    .filter(Boolean)
);

// provider bazlı param isimleri (istersen env ile override edersin)
const PROVIDER_CFG = {
  amazon: { subIdKey: "subid", affIdKey: "aff_id" },
  trendyol: { subIdKey: "subid", affIdKey: "aff_id" },
  hepsiburada: { subIdKey: "subid", affIdKey: "aff_id" },
  n11: { subIdKey: "subid", affIdKey: "aff_id" },
  ciceksepeti: { subIdKey: "subid", affIdKey: "aff_id" },
  booking: { subIdKey: "subid", affIdKey: "aff_id" },
  aliexpress: { subIdKey: "subid", affIdKey: "aff_id" },
};

// ----------------------------
// Utils
// ----------------------------
function b64url(buf) {
  return Buffer.from(buf)
    .toString("base64")
    .replace(/\+/g, "-")
    .replace(/\//g, "_")
    .replace(/=+$/g, "");
}

function safeStr(v) {
  return v == null ? "" : String(v);
}

function normProvider(p) {
  return safeStr(p).toLowerCase().replace(/[^a-z0-9_-]/g, "") || "unknown";
}

function isHttpUrl(u) {
  try {
    const x = new URL(u);
    return x.protocol === "http:" || x.protocol === "https:";
  } catch {
    return false;
  }
}

function parseNumber(v) {
  const n = Number(String(v ?? "").replace(",", "."));
  return Number.isFinite(n) ? n : null;
}

function nowIso() {
  return new Date().toISOString();
}

function getConn() {
  return mongoose?.connection || null;
}

function isDbReady() {
  try {
    const c = getConn();
    // readyState=1 + native conn.db var mı -> startup race keser
    return !!c && c.readyState === 1 && !!c.db;
  } catch {
    return false;
  }
}

function delay(ms) {
  return new Promise((r) => setTimeout(r, ms));
}

async function waitForDbReady(timeoutMs = 8000) {
  const start = Date.now();
  const t = Math.max(0, Number(timeoutMs) || 0);
  while (Date.now() - start < t) {
    if (isDbReady()) return true;
    await delay(120);
  }
  return isDbReady();
}

// ----------------------------
// Models (inline, bağımsız)
// ----------------------------
function getOrCreateModel(name, schema) {
  try {
    return mongoose.model(name);
  } catch {
    return mongoose.model(name, schema);
  }
}

const ClickSchema = new mongoose.Schema(
  {
    clickId: { type: String, index: true, unique: true },
    provider: { type: String, index: true },
    userId: { type: String, index: true, default: null },
    productId: { type: String, index: true, default: null },
    outUrl: { type: String },
    finalUrl: { type: String },
    ipHash: { type: String, default: null },
    uaHash: { type: String, default: null },
    createdAt: { type: Date, default: Date.now },
  },
  { minimize: true, versionKey: false }
);

// 45 gün sonra click log’u uçsun (isteğe göre)
try {
  ClickSchema.index({ createdAt: 1 }, { expireAfterSeconds: 45 * 24 * 3600 });
} catch {}

const ConversionSchema = new mongoose.Schema(
  {
    provider: { type: String, index: true },
    orderId: { type: String, index: true },
    clickId: { type: String, index: true },
    userId: { type: String, index: true, default: null },

    amount: { type: Number, default: null },
    commission: { type: Number, default: null },
    commissionRate: { type: Number, default: null },

    status: { type: String, index: true, default: "unknown" },
    paid: { type: Boolean, index: true, default: false },
    rewardedAt: { type: Date, default: null },

    meta: { type: Object, default: {} },
    createdAt: { type: Date, default: Date.now },
    updatedAt: { type: Date, default: Date.now },
  },
  { minimize: true, versionKey: false }
);

// Dedup anahtarı: provider + orderId (orderId yoksa clickId ile de dedup ederiz)
try {
  ConversionSchema.index({ provider: 1, orderId: 1 }, { unique: true, sparse: true });
  ConversionSchema.index({ provider: 1, clickId: 1 }, { unique: true, sparse: true });
} catch {}

const ClickModel = getOrCreateModel("AffiliateClickS16", ClickSchema);
const ConvModel = getOrCreateModel("AffiliateConversionS16", ConversionSchema);

// ---------------------------------------------------------------------------
// Provider config resolution (env overrides, network defaults)
// - ZERO DELETE: mevcut PROVIDER_CFG tabanı korunur, sadece esnetilir.
// - Env override örnekleri:
//   FAE_NETWORK_DEFAULT=admitad
//   FAE_TRENDYOL_SUBID_KEY=clickref
//   FAE_TRENDYOL_AFFID_KEY=aff_id
//   FAE_TRENDYOL_AFFID_VALUE=12345
// ---------------------------------------------------------------------------
function _normKey(s) {
  return String(s || "")
    .trim()
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, "_")
    .replace(/^_+|_+$/g, "");
}

function _envKey(provider, suffix) {
  const p = _normKey(provider).toUpperCase();
  return `FAE_${p}_${suffix}`;
}

function _readEnv(provider, suffix) {
  return process.env[_envKey(provider, suffix)] ?? null;
}

const _NETWORK_DEFAULTS = {
  // Not: Param adları merchant/ağa göre değişir.
  // Buradaki değerler sadece "başlangıç varsayılanı"; doğrusu partner dökümanına göre ENV ile override edilir.
  admitad: { subIdKey: "subid", affIdKey: "aff_id" },
  awin: { subIdKey: "clickref", affIdKey: "p" },
  impact: { subIdKey: "subId1", affIdKey: "irpid" },
  cj: { subIdKey: "sid", affIdKey: "cjevent" },
};

function resolveProviderCfg(provider) {
  const p = _normKey(provider);
  const base = PROVIDER_CFG[p] || {};

  const net = _normKey(_readEnv(p, "NETWORK") || process.env.FAE_NETWORK_DEFAULT || "");
  const netDefaults = (net && _NETWORK_DEFAULTS[net]) || {};

  const subIdKey =
    _readEnv(p, "SUBID_KEY") ||
    base.subIdKey ||
    netDefaults.subIdKey ||
    "subid";

  const affIdKey =
    _readEnv(p, "AFFID_KEY") ||
    base.affIdKey ||
    netDefaults.affIdKey ||
    "aff_id";

  const affIdValue =
    _readEnv(p, "AFFID_VALUE") ||
    base.affIdValue ||
    process.env.FAE_AFFID_VALUE_DEFAULT ||
    null;

  return {
    ...base,
    network: net || base.network || null,
    subIdKey,
    affIdKey,
    affIdValue,
  };
}


// ----------------------------
// Affiliate URL builder
// ----------------------------

// ============================================================================
// PROVIDER CONTRACTS (S16.1) — outbound/inbound param map single source of truth
// - dev: contract endpoint açık (debug)
// - prod: contract endpoint kapalı (debug=0) veya sadece allowlist
// ============================================================================

const CONTRACT_DEBUG = String(process.env.FAE_AFF_CONTRACT_DEBUG ?? (process.env.NODE_ENV === "production" ? "0" : "1")).trim();
const CONTRACT_DEBUG_ALLOWLIST = String(process.env.FAE_AFF_CONTRACT_DEBUG_ALLOWLIST || "")
  .split(",")
  .map((s) => s.trim().toLowerCase())
  .filter(Boolean);

function debugInfo(req) {
  // DEV diagnostics only (FAE_CONTRACT_DEBUG=1). Never enable in prod publicly.
  if (String(CONTRACT_DEBUG) !== "1") return null;
  try {
    const q = req.query || {};
    const qp = {};
    for (const k of Object.keys(q)) {
      const v = q[k];
      qp[k] = typeof v === "string" ? v.slice(0, 300) : v;
    }
    return {
      path: req.path,
      method: req.method,
      params: req.params || {},
      queryKeys: Object.keys(qp),
      query: qp,
    };
  } catch {
    return { path: req.path, method: req.method };
  }
}

// Canonical table: provider -> contract
// Not: "out.subIdKey" = clickId hangi query paramıyla merchant'a gidiyor
//     "in.clickIdKeys" = postback'te clickId hangi param adlarıyla geri gelebilir
const PROVIDER_CONTRACTS = Object.freeze({
  // Local test provider
  test: {
    out: { subIdKey: "subid", also: [{ key: "fae_click", valueFrom: "clickId" }] },
    in: {
      clickIdKeys: ["clickId", "subid", "fae_click", "sid", "click_id"],
      orderIdKeys: ["orderId", "order_id", "oid"],
      amountKeys: ["amount", "order_sum", "sum", "orderAmount", "transactionAmount"],
      currencyKeys: ["currency", "curr", "transactionCurrency"],
      statusKeys: ["status", "payment_status", "commissionStatus"],
      tokenKeys: ["token", "secret", "x-postback-token"],
    },
  },

  // Example contracts (simulated) — gerçek network dokümantasyonuna göre netleştireceğiz.
  trendyol: {
    out: { subIdKey: "subid4", also: [{ key: "fae_click", valueFrom: "clickId" }] },
    in: {
      clickIdKeys: ["subid4", "subid", "clickId", "fae_click"],
      orderIdKeys: ["order_id", "orderId", "transactionId"],
      amountKeys: ["order_sum", "amount", "transactionAmount"],
      currencyKeys: ["currency", "transactionCurrency"],
      statusKeys: ["payment_status", "status", "commissionStatus"],
      tokenKeys: ["token", "secret", "x-postback-token"],
    },
  },

  hepsiburada: {
    out: { subIdKey: "clickref", also: [{ key: "fae_click", valueFrom: "clickId" }] },
    in: {
      clickIdKeys: ["clickref", "clickId", "subid", "fae_click"],
      orderIdKeys: ["transactionId", "orderId", "order_id"],
      amountKeys: ["transactionAmount", "amount", "order_sum"],
      currencyKeys: ["transactionCurrency", "currency"],
      statusKeys: ["commissionStatus", "status", "payment_status"],
      tokenKeys: ["token", "secret", "x-postback-token"],
    },
  },
});

function canExposeContract(providerKey = "") {
  if (CONTRACT_DEBUG !== "1") return false;
  if (!CONTRACT_DEBUG_ALLOWLIST.length) return true; // dev default: açık
  return CONTRACT_DEBUG_ALLOWLIST.includes(String(providerKey || "").toLowerCase());
}

function mergeContract(base, override) {
  // Shallow merge + array concat for keys
  const out = { ...(base?.out || {}), ...(override?.out || {}) };
  const inBase = base?.in || {};
  const inOver = override?.in || {};
  const inn = {
    clickIdKeys: [...new Set([...(inBase.clickIdKeys || []), ...(inOver.clickIdKeys || [])])],
    orderIdKeys: [...new Set([...(inBase.orderIdKeys || []), ...(inOver.orderIdKeys || [])])],
    amountKeys:  [...new Set([...(inBase.amountKeys  || []), ...(inOver.amountKeys  || [])])],
    currencyKeys:[...new Set([...(inBase.currencyKeys|| []), ...(inOver.currencyKeys|| [])])],
    statusKeys:  [...new Set([...(inBase.statusKeys  || []), ...(inOver.statusKeys  || [])])],
    tokenKeys:   [...new Set([...(inBase.tokenKeys   || []), ...(inOver.tokenKeys   || [])])],
  };
  if (override?.in?.tokenKey) inn.tokenKey = override.in.tokenKey; // single canonical key (optional)
  return { out, in: inn };
}

function resolveProviderContract(provider) {
  const key = normProvider(provider);
  const cfg = resolveProviderCfg(key);

  // base contract = defaults + known provider contract
  const baseDefault = {
    out: {
      subIdKey: cfg.subIdKey || "subid",
      also: [], // extra params to append
    },
    in: {
      clickIdKeys: ["clickId", "subid", "sub_id", "sid", "click_id", "fae_click"],
      orderIdKeys: ["orderId", "order_id", "oid", "transactionId"],
      amountKeys: ["amount", "sum", "order_sum", "transactionAmount"],
      currencyKeys: ["currency", "curr", "transactionCurrency"],
      statusKeys: ["status", "payment_status", "commissionStatus"],
      tokenKeys: ["token", "secret", "x-postback-token"],
    },
  };

  const known = PROVIDER_CONTRACTS[key] || null;

  // ENV override (tek tek provider bazlı hızlı fix)
  // FAE_AFF_<PROV>_SUBID_KEY=...
  // FAE_AFF_<PROV>_IN_CLICK_KEYS=clickref,subid4,clickId
  // FAE_AFF_<PROV>_IN_ORDER_KEYS=order_id,transactionId
  // ...
  const P = String(key || "").toUpperCase().replace(/[^A-Z0-9]+/g, "_");
  const envList = (k) =>
    String(process.env[k] || "")
      .split(",")
      .map((s) => s.trim())
      .filter(Boolean);

  const over = {
    out: {
      subIdKey: String(process.env[`FAE_AFF_${P}_SUBID_KEY`] || "").trim() || undefined,
    },
    in: {
      clickIdKeys: envList(`FAE_AFF_${P}_IN_CLICK_KEYS`),
      orderIdKeys: envList(`FAE_AFF_${P}_IN_ORDER_KEYS`),
      amountKeys: envList(`FAE_AFF_${P}_IN_AMOUNT_KEYS`),
      currencyKeys: envList(`FAE_AFF_${P}_IN_CURRENCY_KEYS`),
      statusKeys: envList(`FAE_AFF_${P}_IN_STATUS_KEYS`),
      tokenKeys: envList(`FAE_AFF_${P}_IN_TOKEN_KEYS`),
    },
  };

  const merged = mergeContract(mergeContract(baseDefault, known), over);

  // affIdKey/affIdValue (varsa) outbound'a ekleyelim (bunu zaten buildAffiliateUrl yapıyordu)
  if (cfg.affIdKey && cfg.affIdValue) {
    merged.out.also = [
      ...(merged.out.also || []),
      { key: cfg.affIdKey, value: cfg.affIdValue },
    ];
  }

  return merged;
}
function buildAffiliateUrl(provider, rawUrl, clickId) {
  // Canonical outbound builder (S16.1): provider contract -> query params
  const p = normProvider(provider);
  const cfg = resolveProviderCfg(p);
  const contract = resolveProviderContract(p);

  try {
    const url = new URL(rawUrl);

    // click tracking: provider-specific subid key
    const subKey = String(contract?.out?.subIdKey || cfg?.subIdKey || "subid").trim() || "subid";
    url.searchParams.set(subKey, String(clickId));

    // Extra outbound params (constant or derived)
    const also = Array.isArray(contract?.out?.also) ? contract.out.also : [];
    for (const a of also) {
      const k = String(a?.key || "").trim();
      if (!k) continue;

      if (a?.valueFrom === "clickId") {
        url.searchParams.set(k, String(clickId));
        continue;
      }
      if (typeof a?.value === "string" && a.value) {
        url.searchParams.set(k, a.value);
        continue;
      }
    }

    // Back-compat: if cfg has explicit affIdKey/value (resolveProviderContract already adds it,
    // but duplicates are harmless because last write wins)
    if (cfg?.affIdKey && cfg?.affIdValue) {
      url.searchParams.set(String(cfg.affIdKey), String(cfg.affIdValue));
    }

    return url.toString();
  } catch (e) {
    // Do not crash pipeline
    return String(rawUrl || "");
  }
}



// ----------------------------
// Helper: userId kaynağı (GÜVENLİK)
// ----------------------------
// Burada kritik nokta: client'tan gelen uid'ye güvenmek ÇÖP.
// En doğrusu: auth middleware req.user koyar, buradan okursun.
// Yoksa uid'yi NULL bırak -> anonymous click, reward yok (daha güvenli).
function getAuthedUserId(req) {
  try {
    const u = req.user || null;
    const id = u?._id || u?.id || u?.userId || null;
    return id ? String(id) : null;
  } catch {
    return null;
  }
}

function hashLite(s) {
  try {
    return crypto.createHash("sha256").update(String(s || "")).digest("hex").slice(0, 24);
  } catch {
    return null;
  }
}

// ===================================================================
// GET /out/:provider?u=<encodedUrl>&pid=<productId>
// ===================================================================

// Alias: /out?provider=...&url=... (kanonik: /out/:provider)
router.get("/out", (req, res) => {
  try {
    const provider = String(req.query?.provider || "").trim();
    if (!provider) return res.status(400).json({ ok: false, error: "MISSING_PROVIDER" });
    const qs = new URLSearchParams();
    for (const [k, v] of Object.entries(req.query || {})) {
      if (k === "provider") continue;
      if (v === undefined || v === null) continue;
      qs.set(k, String(v));
    }
    const target = `/api/aff/out/${encodeURIComponent(provider)}?${qs.toString()}`;
    return res.redirect(302, target);
  } catch (e) {
    return res.status(500).json({ ok: false, error: "OUT_ALIAS_FAIL" });
  }
});

router.get("/out/:provider", async (req, res) => {
  const provider = normProvider(req.params.provider);
  const raw = safeStr(req.query.u || req.query.url || "");
  const productId = safeStr(req.query.pid || req.query.productId || req.query.itemId || req.query.itemID || req.query.sku || req.query.id || "") || null;

  const outUrl = (() => {
    try {
      return decodeURIComponent(raw);
    } catch {
      return raw;
    }
  })();

  if (!outUrl || !isHttpUrl(outUrl)) {
    const dbg = debugInfo(req);
    return res.status(400).json({ ok: false, error: "BAD_URL", provider, ...(dbg ? { debug: dbg } : {}) });
  }

  // DB yoksa: PROD'da BLOKLA (para kaybı), DEV'da isteğe bağlı izin ver
  if (!isDbReady()) {
    if (!OUT_ALLOW_WHEN_DB_DOWN) {
      return res.status(503).json({
        ok: false,
        error: "DB_NOT_READY",
        note:
          "DB hazır değilken /out çalıştırmak clickId kaybı demek. PROD'da blokladım.",
        db: { readyState: getConn()?.readyState ?? -1 },
        ts: nowIso(),
      });
    }
  }

  const clickId = b64url(crypto.randomBytes(16));
  const userId = getAuthedUserId(req); // güvenli
  const ipHash = hashLite(req.ip || req.headers["x-forwarded-for"] || "");
  const uaHash = hashLite(req.headers["user-agent"] || "");

  const finalUrl = buildAffiliateUrl(provider, outUrl, clickId);

  // Log click (DB hazırsa)
  if (isDbReady()) {
    try {
      const q = ClickModel.create({
        clickId,
        provider,
        userId,
        productId,
        outUrl,
        finalUrl,
        ipHash,
        uaHash,
      });
      await q;
    } catch (e) {
      // click log başarısızsa redirect edip para kaybetme; ama bu ciddi alarm
      console.warn("⚠️ S16 /out click log failed:", e?.message || e);
    }
  }

  // noindex + 302
  res.setHeader("X-Robots-Tag", "noindex, nofollow");
  res.setHeader("Cache-Control", "no-store");
  return res.redirect(302, finalUrl);
});

// ===================================================================
// POST/GET /postback/:provider
// - token doğrulaması opsiyonel ama ŞİDDETLE önerilir.
// - beklenen paramlar: clickId/subid, orderId, amount, status, commission...
// ===================================================================
async function extractPostback(req) {
  // Provider-aware postback parser (S16.1)
  const provider = normProvider(req?.params?.provider || req?.query?.provider || "");
  const contract = resolveProviderContract(provider);

  const src = Object.assign({}, req?.query || {}, req?.body || {}, req?.params || {});
  const srcKeys = Object.keys(src || {});
  const getAny = (keys) => {
    for (const k0 of keys || []) {
      const k = String(k0 || "").trim();
      if (!k) continue;
      if (src[k] !== undefined && src[k] !== null && String(src[k]).trim() !== "") return src[k];

      // case-insensitive fallback
      const kk = srcKeys.find((x) => String(x).toLowerCase() === k.toLowerCase());
      if (kk && src[kk] !== undefined && src[kk] !== null && String(src[kk]).trim() !== "") return src[kk];
    }
    return null;
  };

  const clickId = safeStr(getAny(contract?.in?.clickIdKeys) || "");
  const orderId = safeStr(getAny(contract?.in?.orderIdKeys) || "");
  const amountRaw = getAny(contract?.in?.amountKeys);
  const amount = parseNumber(amountRaw);

  const currency = safeStr(getAny(contract?.in?.currencyKeys) || "");
  const status = safeStr(getAny(contract?.in?.statusKeys) || "");
  const statusNorm = normalizeStatus(status);

  // paid: explicit flag (rare) OR infer from status (common)
  const paidRaw = getAny([
    "paid",
    "is_paid",
    "isPaid",
    "commission_paid",
    "payment_paid",
    "paid_status",
    "ispaid",
  ]);
  let paid = null;
  if (paidRaw !== undefined && paidRaw !== null && String(paidRaw).trim() !== "") {
    const p = normalizeStatus(paidRaw);
    paid = ["1", "true", "yes", "paid", "approved"].includes(p);
  } else {
    paid = PAID_STATUSES.has(statusNorm);
  }


  // token: body/query + headers
  const tokenFromSrc = safeStr(getAny(contract?.in?.tokenKeys) || "");
  const tokenFromHdr = safeStr(
    req?.headers?.["x-postback-token"] ||
      req?.headers?.["x_postback_token"] ||
      req?.headers?.["x-postback-secret"] ||
      ""
  );
  const token = (tokenFromSrc || tokenFromHdr || "").trim();

  return {
    provider,
    clickId: clickId || null,
    orderId: orderId || null,
    amount,
    currency: currency || null,
    status: statusNorm || null,
    paid,
    token: token || null,
    raw: src,
  };
}




// Alias: /postback?provider=... (kanonik: /postback/:provider)
// -------------------------------------------------------------------
// GET /contract/:provider — provider param sözleşmesini göster (dev debug)
// -------------------------------------------------------------------
router.get("/contract", (req, res) => {
  try {
    const provider = safeStr(req?.query?.provider || req?.query?.p || "");
    if (!provider) {
      // list contracts (names only)
      return res.json({
        ok: true,
        contracts: Object.keys(PROVIDER_CONTRACTS),
        note: "Use /api/aff/contract/:provider (dev only unless allowlisted).",
      });
    }
    return res.redirect(302, `/api/aff/contract/${encodeURIComponent(provider)}`);
  } catch (e) {
    return res.status(500).json({ ok: false, error: "CONTRACT_ALIAS_FAIL" });
  }
});

router.get("/contract/:provider", (req, res) => {
  const provider = normProvider(req.params.provider);
  if (!canExposeContract(provider)) {
    // prod default: görünmesin (security + surface area)
    return res.status(404).json({ ok: false, error: "NOT_FOUND" });
  }

  const contract = resolveProviderContract(provider);
  return res.json({
    ok: true,
    provider,
    out: {
      subIdKey: contract?.out?.subIdKey || "subid",
      also: (contract?.out?.also || []).map((x) => ({ key: x.key, valueFrom: x.valueFrom || (x.value ? "const" : undefined) })),
      example: `GET /api/aff/out/${provider}?url=https%3A%2F%2Fmerchant.com%2Fitem&itemId=...&title=... (redirect adds ${contract?.out?.subIdKey || "subid"}=<clickId>)`,
    },
    in: {
      clickIdKeys: contract?.in?.clickIdKeys || [],
      orderIdKeys: contract?.in?.orderIdKeys || [],
      amountKeys: contract?.in?.amountKeys || [],
      currencyKeys: contract?.in?.currencyKeys || [],
      statusKeys: contract?.in?.statusKeys || [],
      tokenKeys: contract?.in?.tokenKeys || [],
      example: `GET /api/aff/postback/${provider}?${(contract?.in?.clickIdKeys||["clickId"])[0]}=<clickId>&${(contract?.in?.orderIdKeys||["orderId"])[0]}=<orderId>&${(contract?.in?.amountKeys||["amount"])[0]}=100&${(contract?.in?.currencyKeys||["currency"])[0]}=TRY&${(contract?.in?.statusKeys||["status"])[0]}=approved`,
    },
    debug: {
      enabled: true,
      allowlist: CONTRACT_DEBUG_ALLOWLIST,
    },
  });
});

router.all("/postback", (req, res) => {
  try {
    const provider = String(req.query?.provider || req.body?.provider || "").trim();
    if (!provider) return res.status(400).json({ ok: false, error: "MISSING_PROVIDER" });
    const target = `/api/aff/postback/${encodeURIComponent(provider)}`;
    return res.redirect(307, target);
  } catch (e) {
    return res.status(500).json({ ok: false, error: "POSTBACK_ALIAS_FAIL" });
  }
});

router.all("/postback/:provider", async (req, res) => {
  // DB yoksa postback'i kaybetmek ölümcül: kısa bekle, yine yoksa 503
  if (!isDbReady()) {
    const ok = await waitForDbReady(Number(process.env.FAE_POSTBACK_DB_WAIT_MS || 8000));
    if (!ok) {
      return res.status(503).json({
        ok: false,
        error: "DB_NOT_READY",
        note: "Postback DB olmadan işlenemez. Bu para kaybıdır.",
        db: { readyState: getConn()?.readyState ?? -1 },
        ts: nowIso(),
      });
    }
  }

  const pb = await extractPostback(req);

  // Token doğrulama (env varsa zorunlu)
  if (POSTBACK_SECRET) {
    if (!pb.token || pb.token !== POSTBACK_SECRET) {
      return res.status(403).json({
        ok: false,
        error: "POSTBACK_FORBIDDEN",
        provider: pb.provider,
      });
    }
  }

  if (!pb.clickId && !pb.orderId) {
    const dbg = debugInfo(req);
    return res.status(400).json({ ok: false, error: "MISSING_CLICK_OR_ORDER_ID", provider: pb.provider, ...(dbg ? { debug: dbg } : {}) });
  }

  // click -> user resolve
  let click = null;
  try {
    if (pb.clickId) {
      click = await ClickModel.findOne({ clickId: pb.clickId }).lean();
    }
  } catch {}

  const userId = click?.userId ? String(click.userId) : null;

  // Dedup: önce conversion kaydı (provider+orderId) veya (provider+clickId)
  let conv = null;
  try {
    const keyQuery = pb.orderId
      ? { provider: pb.provider, orderId: pb.orderId }
      : { provider: pb.provider, clickId: pb.clickId };

    conv = await ConvModel.findOne(keyQuery);

    // Zaten paid + rewarded ise tekrar ödeme YOK
    if (conv?.paid && conv?.rewardedAt) {
      return res.json({
        ok: true,
        dedup: true,
        provider: pb.provider,
        orderId: pb.orderId || null,
        clickId: pb.clickId || null,
        alreadyRewardedAt: conv.rewardedAt,
      });
    }
  } catch {}

  // Upsert conversion
  try {
    const keyQuery = pb.orderId
      ? { provider: pb.provider, orderId: pb.orderId }
      : { provider: pb.provider, clickId: pb.clickId };

    conv = await ConvModel.findOneAndUpdate(
      keyQuery,
      {
        $set: {
          provider: pb.provider,
          orderId: pb.orderId || null,
          clickId: pb.clickId || null,
          userId: userId || null,
          amount: pb.amount,
          commission: pb.commission,
          commissionRate: pb.commissionRate,
          status: pb.status,
          paid: !!pb.paid,
          meta: { ...pb.raw },
          updatedAt: new Date(),
        },
        $setOnInsert: { createdAt: new Date() },
      },
      { upsert: true, new: true }
    );
  } catch (e) {
    return res.status(500).json({
      ok: false,
      error: "CONVERSION_UPSERT_FAILED",
      msg: e?.message || String(e),
    });
  }

  // Paid değilse burada biter (pending olarak kaydettik)
  if (!pb.paid) {
    return res.json({
      ok: true,
      provider: pb.provider,
      status: pb.status,
      paid: false,
      note: "Conversion kaydedildi. Paid olunca reward tetiklenecek.",
    });
  }

  // Paid ama user yoksa: reward veremeyiz (click mapping yok)
  if (!userId) {
    return res.json({
      ok: true,
      provider: pb.provider,
      paid: true,
      rewardApplied: false,
      reason: "NO_USER_MAPPING_FROM_CLICK",
      clickId: pb.clickId || null,
      orderId: pb.orderId || null,
    });
  }

  // RewardEngine gate'leri için order objesi üret
  // - affiliateId = FAE_AFFILIATE_ID (yoksa rewardEngine zaten bloklar)
  // - commissionPaid=true ve commission_status='paid'
  const orderLike = {
    id: pb.orderId || undefined,
    _id: pb.orderId || undefined,
    orderId: pb.orderId || undefined,

    userId,
    provider: pb.provider,

    purchaseAmount: pb.amount ?? 0,
    amount: pb.amount ?? 0,
    totalPrice: pb.amount ?? 0,

    commission: pb.commission ?? 0,
    commissionRate: pb.commissionRate ?? null,

    affiliateId: AFFILIATE_ID || null,
    commissionPaid: true,
    commission_status: "paid",

    clickId: pb.clickId || null,
  };

  // Reward uygula + conv.rewardedAt işaretle
  let rewardRes = null;
  try {
    rewardRes = await applyRewardsForOrder(orderLike);

    // reward başarılıysa işaretle (dedup için)
    if (rewardRes?.ok) {
      try {
        await ConvModel.updateOne(
          { _id: conv._id },
          { $set: { rewardedAt: new Date(), updatedAt: new Date() } }
        );
      } catch {}
    }
  } catch (e) {
    console.warn("⚠️ applyRewardsForOrder failed:", e?.message || e);
  }

  return res.json({
    ok: true,
    provider: pb.provider,
    paid: true,
    clickId: pb.clickId || null,
    orderId: pb.orderId || null,
    userId,
    rewardResult: rewardRes || null,
  });
});

export default router;
